const formatName = (value = "") =>
  value
    .slice(0, value.indexOf("."))
    .replace(/\b[a-z]/, (v) => v[0].toUpperCase())
    .replace(/-./g, (v) => v[1].toUpperCase());

(() => {
  const path = require("node:path");
  const fs = require("node:fs");

  const baseUrl = path.resolve(
    __dirname,
    "../",
    "src",
    "shared",
    "ui",
    "atoms",
    "icon",
    "ui",
  );

  const iconVariants = fs
    .readdirSync(baseUrl)
    .filter((item) => !item.includes("."));

  fs.writeFileSync(
    path.resolve(baseUrl, "index.type.ts"),
    `
    // THIS FILE IS AUTOGENERATED!
    export type IconProps = {
    variant?: ${iconVariants.map((item) => `"${item}"`).join("|")}
    }
    `,
  );

  let icons = [];

  let isIconsEquals = false;

  iconVariants.forEach((variant, variantIdx, variants) => {
    const variantPath = path.resolve(baseUrl, variant);
    const variantIcons = fs.readdirSync(variantPath);

    const restVariants = structuredClone(variants);
    restVariants.splice(variantIdx, 1);

    isIconsEquals = !restVariants.some((otherVariant) => {
      const otherVariantPath = path.resolve(baseUrl, otherVariant);
      const restVariantIcons = fs.readdirSync(otherVariantPath);
      const brokenIcons = variantIcons.filter(
        (item) => !restVariantIcons.includes(item),
      );

      if (brokenIcons.length) {
        brokenIcons.forEach((item) =>
          console.error(
            `A broken icon was found❗️\nFound in ${path.resolve(variantPath, item)} but not found in ${otherVariantPath}`,
          ),
        );

        return;
      }
    });

    icons = variantIcons;
  });

  if (!isIconsEquals) {
    console.error("Add or remove non-existent icons");
    return;
  }

  icons.forEach((icon) => {
    const iconInner = iconVariants.reduce(
      (acc, variant) => ({
        ...acc,
        [variant]: fs
          .readFileSync(path.resolve(baseUrl, variant, icon), "utf-8")
          .replace(`="white"`, `="currentColor"`),
      }),
      {},
    );

    const componentName = formatName(icon);

    fs.writeFileSync(
      path.resolve(baseUrl, icon.replace(".svg", ".tsx")),
      `
      import { type IconProps } from "./index.type"

      export const ${componentName} = ({variant = "${iconVariants[0]}"}: IconProps) => {
        switch(variant) {
            ${iconVariants
              .map(
                (variant) => `
            case "${variant}":
                return ${iconInner[variant]};
            `,
              )
              .join("")}
            default:
                return ${iconInner[iconVariants[0]]};
        }
      }
      `,
    );

    iconVariants.forEach((variant) =>
      fs.unlinkSync(path.resolve(baseUrl, variant, icon)),
    );
  });

  fs.writeFileSync(
    path.resolve(baseUrl, "index.ts"),
    icons
      .map((icon) => `export * from "./${icon.slice(0, icon.indexOf("."))}";`)
      .join("\n"),
  );
})();
